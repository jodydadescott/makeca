#!/bin/sh

EMAIL="$(whoami)@local.dev"

main() {
	usage="Usage:$0 store_dir dname"
	store=$1
	dname=$2
	[[ $store ]] || { err $usage; return 2; }
	[[ $dname ]] || { err $usage; return 2; }
	[ -d $store ] && { err "Directory $store already exist; aborting"; return 2; }
	[ -f $store ] && { err "File $store already exist; aborting"; return 2; }
	_parse_dname $dname
	DIR_CN="root"
	mkdir -p $store || return 3
	cd $store || return 3
	touch ca || return 3
	echo_ca_cnf > ca.cnf || return 3
	echo_signcert > signcert || return 3
	echo_makecert > makecert || return 3
	chmod +x signcert makecert || return 3
	mkdir -p certs sign_request newcerts || return 3
	openssl rand -base64 32 > passphrase || return 3
	chmod 0400 passphrase || return 3
	touch index || return 3
	echo 200000 > serial || return 3
	# Generate private key
	openssl genrsa -passout file:passphrase -des3 -out ca.pem 2048 || return 3
	chmod 0400 ca.pem || return 3
	# Extract Public Key
	openssl rsa -passin file:passphrase -in ca.pem -pubout > ca_pub.pem || return 3
	# Generate root certificate
	openssl req -passin file:passphrase -x509 -new -nodes -key ca.pem -sha256 -days 36500 -out ca.crt -config ca.cnf || return 3
	err "Store $store created"
}

_parse_dname() {
	for i in ${1//,/ }; do
		key=$(echo $i | cut -d'=' -f1)
		value=$(echo $i | cut -d'=' -f2)
		[[ "$key" == "CN" ]] && DIR_CN=$value
		[[ "$key" == "OU" ]] && DIR_OU=$value
		[[ "$key" == "O" ]] && DIR_O=$value
		[[ "$key" == "ST" ]] && DIR_ST=$value
		[[ "$key" == "C" ]] && DIR_C=$value
	done
}

echo_ca_cnf() {
	cat <<-EOF
	HOME			= .
	RANDFILE		= \$ENV::HOME/.rnd
	oid_section		= new_oids

	[ new_oids ]

	[ ca ]
	default_ca	= CA_default

	[ CA_default ]
	dir		= \$HOME
	certs		= \$dir/certs
	crl_dir		= \$dir/crl
	database	= \$dir/index
	unique_subject	= no
	new_certs_dir	= \$dir/newcerts
	certificate	= \$dir/ca.crt
	serial		= \$dir/serial
	crlnumber	= \$dir/crlnumber
	crl		= \$dir/crl.pem
	private_key	= \$dir/ca.pem
	RANDFILE	= \$dir/.rand
	x509_extensions	= usr_cert
	name_opt 	= ca_default
	cert_opt 	= ca_default
	default_days	= 36500	
	default_crl_days= 30
	default_md	= sha1
	preserve	= no
	policy		= policy_match

	[ policy_match ]
	countryName		= optional
	stateOrProvinceName	= optional
	organizationName	= optional
	organizationalUnitName	= optional
	commonName		= supplied
	emailAddress	= optional

	[ policy_anything ]
	countryName		= optional
	stateOrProvinceName	= optional
	localityName		= optional
	organizationName	= optional
	organizationalUnitName	= optional
	commonName		= supplied
	emailAddress		= optional

	[ req ]
	default_bits		= 1024
	default_keyfile 	= privkey.pem
	distinguished_name	= req_distinguished_name
	attributes		= req_attributes
	x509_extensions	= v3_ca
	# input_password = notasecret
	# output_password = notasecret

	string_mask = nombstr

	[ req_distinguished_name ]
	countryName			= Country Name (2 letter code)
	countryName_default		= $DIR_C
	countryName_min			= 2
	countryName_max			= 2

	stateOrProvinceName		= State or Province Name (full name)
	stateOrProvinceName_default	= $DIR_ST

	0.organizationName		= Organization Name (eg, company)
	0.organizationName_default	= $DIR_O

	organizationalUnitName		= Organizational Unit Name (eg, section)
	organizationalUnitName_default	= $DIR_OU

	commonName			= Common Name (e.g. server FQDN or YOUR name)
	commonName_max			= 64
	commonName_default = $DIR_CN

	emailAddress			= Email Address
	emailAddress_max		= 64
	emailAddress_default		= $EMAIL

	[ req_attributes ]
	challengePassword		= A challenge password
	challengePassword_min		= 4
	challengePassword_max		= 20

	unstructuredName		= An optional company name

	[ usr_cert ]

	basicConstraints=CA:FALSE

	nsComment			= "Not Production"

	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid,issuer

	[ v3_req ]
	basicConstraints = CA:FALSE
	keyUsage = nonRepudiation, digitalSignature, keyEncipherment

	[ v3_ca ]
	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid:always,issuer:always
	basicConstraints = CA:true

	[ crl_ext ]

	authorityKeyIdentifier=keyid:always,issuer:always

	[ proxy_cert_ext ]
	basicConstraints=CA:FALSE

	nsComment			= "Not Production"
	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid,issuer:always
	proxyCertInfo=critical,language:id-ppl-anyLanguage,pathlen:3,policy:foo
	EOF
}

echo_signcert() {
	cat <<-'EOF'
	#!/bin/sh
	# openssl req -in jody.req -noout -text
	main() {
	  cd $(dirname $0)
	  counter=0
	  mkdir -p sign_request
	  mkdir -p newcerts
	  err "Processing certs"
	  for cert in $(/bin/ls -1 sign_request); do
	    basecert=$(echo $cert | rev | cut -f 2- -d '.' | rev)
	    err "Processing $cert"
	    [ -f certs/${basecert}.crt ] && { err "Existing cert with name $cert; ignoring"; continue; }
	    tmp=$(mktemp)
	    openssl ca -config ca.cnf -passin file:passphrase -batch -out $tmp -infiles sign_request/$cert ||
	      { err "Failed to sign cert $cert"; rm $tmp;  continue; }
	    let counter=counter+1
	    mv $tmp certs/${basecert}.crt
	    rm sign_request/$cert
	    err "Signed cert ${basecert}"
	  done    
	  err "Signed $counter certs"
	}
	err() { echo "$@" 1>&2; }
	main $@
	EOF
}

echo_makecert(){
cat <<EOF
#!/bin/bash

main() {
	which openssl > /dev/null 2>&1 || { err "Unable to find openssl in path"; return 2; }
	local name=\$1
	local dname=\$2
	local pass=\$3
	local output_dir=\$4
	pushd \$(dirname \$0) > /dev/null 2>&2
	ca=\$PWD
	popd > /dev/null 2>&1
	local usage="Usage \$0 name dname pass output_dir"
	[[ \$name ]] || { err \$usage; return 2; }
	[[ \$dname ]] || { err \$usage; return 2; }
	[[ \$pass ]] || { err \$usage; return 2; }
	[[ \$output_dir ]] || { err \$usage; return 2; }
	[ -d \$output_dir ] || mkdir -p \$output_dir
	cd \$output_dir
	[ -f \${ca}/certs/\${name}.crt ] && { err "Cert with name \$name already exist"; return 2; }
	[ -d \$name ] && { err "Directory with name \$name already exist"; return 2; }
	mkdir \$name || { err "Unable to create directory \$name"; return 2; }
	cd \$name 
	cp \${ca}/ca.crt . || { err "Unable to copy file \${ca}/ca.crt"; return 2; }
	openssl genrsa -out key 2048 || { err "Unable to generate key"; return 2; }
	local subject="/CN=\${name}/\${dname}"
	openssl req -new -key key -out csr -subj \$subject -passin pass:\${pass} ||
		{ err "Unable to create request"; return 2; }
	mv csr \${ca}/sign_request/\${name}.csr ||
		{ err "Unable to move csr to \${ca}/sign_request"; return 2; }
	\${ca}/signcert || { err "Unable so sign request"; return 2; }
	cp \${ca}/certs/\${name}.crt crt ||
		{ err "Unable to copy file \${ca}/certs/\${name}.crt"; return 2; }
	openssl pkcs12 -export -in crt -inkey key -name \${name} -out p12 -passout pass:\${pass}
	which keytool > /dev/null 2>&1 || { err "keytool not found, keystore will not be created"; return 0; }
	keytool -import  -noprompt -storepass \$pass -keystore keystore -alias root -trustcacerts -file ca.crt ||
		{ err "keystore creation/importation of ca.crt failed"; return 2; }
	keytool -importkeystore -deststorepass \$pass -destkeystore keystore -srckeystore p12 -srcstorepass \$pass -srcstoretype PKCS12 ||
		{ err "keystore importation of pkcs12 failed"; return 2; }
}

err() { echo "\$@" 1>&2; }
main \$@

EOF
}

err() { echo "$@" 1>&2; }

main $@
