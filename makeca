#!/bin/sh

EMAIL="$(whoami)@local.dev"

main() {
	store=$1
	[[ $store ]] || { err "Usage:$0 store_dir"; return 2; }
	[ -d $store ] && { err "Directory $store already exist; aborting"; return 2; }
	[ -f $store ] && { err "File $store already exist; aborting"; return 2; }
	mkdir -p $store || return 3
	touch ca || return 3
	gen_ca_cnf > ca.cnf || return 3
	gen_bin_signcert > signcert || return 3
	gen_bin_make_plaincert > make_plaincert || return 3
	gen_bin_make_keytool > make_keytool || return 3
	chmod +x signcert || return 3
	chmod +x make_plaincert || return 3
	chmod +x make_keytool || return 3
	mkdir -p certs sign_request newcerts || return 3
	openssl rand -base64 32 > passphrase || return 3
	chmod 0400 passphrase || return 3
	touch index || return 3
	echo 200000 > serial || return 3
	# Generate private key
	openssl genrsa -passout file:passphrase -des3 -out ca.pem 2048 || return 3
	chmod 0400 ca.pem || return 3
	# Extract Public Key
	openssl rsa -passin file:passphrase -in ca.pem -pubout > ca_pub.pem || return 3
	# Generate root certificate
	openssl req -passin file:passphrase -x509 -new -nodes -key ca.pem -sha256 -days 36500 -out ca.crt -config ca.cnf || return 3
	err "Store $store created"
}

gen_ca_cnf() {
	cat <<-EOF
	HOME			= .
	RANDFILE		= \$ENV::HOME/.rnd
	oid_section		= new_oids

	[ new_oids ]

	[ ca ]
	default_ca	= CA_default

	[ CA_default ]
	dir		= \$HOME
	certs		= \$dir/certs
	crl_dir		= \$dir/crl
	database	= \$dir/index
	unique_subject	= no
	new_certs_dir	= \$dir/newcerts
	certificate	= \$dir/ca.crt
	serial		= \$dir/serial
	crlnumber	= \$dir/crlnumber
	crl		= \$dir/crl.pem
	private_key	= \$dir/ca.pem
	RANDFILE	= \$dir/.rand
	x509_extensions	= usr_cert
	name_opt 	= ca_default
	cert_opt 	= ca_default
	default_days	= 36500	
	default_crl_days= 30
	default_md	= sha1
	preserve	= no
	policy		= policy_match

	[ policy_match ]
	countryName		= optional
	stateOrProvinceName	= optional
	organizationName	= optional
	organizationalUnitName	= optional
	commonName		= supplied
	emailAddress	= optional

	[ policy_anything ]
	countryName		= optional
	stateOrProvinceName	= optional
	localityName		= optional
	organizationName	= optional
	organizationalUnitName	= optional
	commonName		= supplied
	emailAddress		= optional

	[ req ]
	default_bits		= 1024
	default_keyfile 	= privkey.pem
	distinguished_name	= req_distinguished_name
	attributes		= req_attributes
	x509_extensions	= v3_ca
	# input_password = notasecret
	# output_password = notasecret

	string_mask = nombstr

	[ req_distinguished_name ]
	countryName			= Country Name (2 letter code)
	countryName_default		= US
	countryName_min			= 2
	countryName_max			= 2

	stateOrProvinceName		= State or Province Name (full name)
	stateOrProvinceName_default	= TX

	0.organizationName		= Organization Name (eg, company)
	0.organizationName_default	= TechBros

	organizationalUnitName		= Organizational Unit Name (eg, section)
	organizationalUnitName_default	= Widgets

	commonName			= Common Name (e.g. server FQDN or YOUR name)
	commonName_max			= 64
	commonName_default = root

	emailAddress			= Email Address
	emailAddress_max		= 64
	emailAddress_default		= $EMAIL

	[ req_attributes ]
	challengePassword		= A challenge password
	challengePassword_min		= 4
	challengePassword_max		= 20

	unstructuredName		= An optional company name

	[ usr_cert ]

	basicConstraints=CA:FALSE

	nsComment			= "Not Production"

	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid,issuer

	[ v3_req ]
	basicConstraints = CA:FALSE
	keyUsage = nonRepudiation, digitalSignature, keyEncipherment

	[ v3_ca ]
	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid:always,issuer:always
	basicConstraints = CA:true

	[ crl_ext ]

	authorityKeyIdentifier=keyid:always,issuer:always

	[ proxy_cert_ext ]
	basicConstraints=CA:FALSE

	nsComment			= "Not Production"
	subjectKeyIdentifier=hash
	authorityKeyIdentifier=keyid,issuer:always
	proxyCertInfo=critical,language:id-ppl-anyLanguage,pathlen:3,policy:foo
	EOF
}

gen_bin_signcert() {
	cat <<-'EOF'
	#!/bin/sh
	# openssl req -in jody.req -noout -text
	main() {
	  cd $(dirname $0)
	  counter=0
	  mkdir -p sign_request
	  mkdir -p newcerts
	  err "Processing certs"
	  for cert in $(/bin/ls -1 sign_request); do
	    basecert=$(echo $cert | rev | cut -f 2- -d '.' | rev)
	    err "Processing $cert"
	    [ -f certs/${basecert}.crt ] && { err "Existing cert with name $cert; ignoring"; continue; }
	    tmp=$(mktemp)
	    openssl ca -config ca.cnf -passin file:passphrase -batch -out $tmp -infiles sign_request/$cert ||
	      { err "Failed to sign cert $cert"; rm $tmp;  continue; }
	    let counter=counter+1
	    mv $tmp certs/${basecert}.crt
	    rm sign_request/$cert
	    err "Signed cert ${basecert}"
	  done    
	  err "Signed $counter certs"
	}
	err() { echo "$@" 1>&2; }
	main $@
	EOF
}

gen_bin_make_plaincert(){
cat <<EOF
#!/bin/sh

main() {
  ca=\$(dirname \$0)
  cert_name=\$(basename \$1)
  cert_dir=\$(dirname \$1)/\${cert_name}

  [[ \$cert_name ]] || { err "Usage: \$0 cert_name"; return 2; }
  [ -d \$cert_dir ] && { err "Directory \$cert exist"; return 2; }
  [ -f \$cert_dir ] && { err "File \$cert exist"; return 2; }
  mkdir -p \$cert_dir

  local reqout=\${ca}/sign_request/\${cert_name}.req
  openssl genrsa -out \${cert_dir}/key.pem 2048
  local subject="/C=US/ST=TX/L=Southlake/O=TechBros/OU=Widgets/CN=$EMAIL"
  openssl req -nodes -newkey rsa:2048 -keyout key.pem -out \$reqout -subj \$subject
  \${ca}/signcert
  cp \${ca}/certs/\${cert_name}.crt \${cert_dir}/key.crt
  cp \${ca}/ca.crt \${cert_dir}/ca.crt
}

err() { echo "\$@" 1>&2; }
main \$@
EOF
}


gen_bin_make_keytool(){
cat <<EOF
#!/bin/sh

main() {
  local name=\$1
  local dname=\$2
  local pass=\$3
  local output_dir=\$4
  cd \$(dirname \$0)
  ca=\$PWD
  local usage="Usage \$0 name dname pass output_dir"
  [[ \$name ]] || { err \$usage; return 2; }
  [[ \$dname ]] || { err \$usage; return 2; }
  [[ \$pass ]] || { err \$usage; return 2; }
  [[ \$output_dir ]] || { err \$usage; return 2; }

  [ -d \$output_dir ] || mkdir -p \$output_dir
  cd \$output_dir
  [ -f \${ca}/certs/\${name}.crt ] && { err "Cert with name \$name already exist"; return 2; }
  [ -d \$name ] && { err "Directory with name \$name already exist"; return 2; }

  mkdir \$name && cd \$name
  log=$(mktemp)
  _keytool \$ca \$name \$dname \$pass > \$log 2>&1
  rc=\$?
  [ \$rc -eq 0 ] || { cat \$log; }
  rm \$log
  return \$?
}

_keytool() {
  local ca=\$1
  local name=\$2
  local dname=\$3
  local pass=\$4
  keytool -import  -noprompt -storepass \$pass -keystore keystore -alias root -trustcacerts -file \${ca}/ca.crt || return 2
  keytool -genkey  -noprompt -storepass \$pass -keystore keystore -alias \$name -keyalg RSA -dname CN=client1,\${dname} -keysize 2048 || return 2
  keytool -certreq -noprompt -storepass \$pass -keystore keystore -alias \$name -file \${ca}/sign_request/\${name}.csr && \${ca}/signcert || return 2
  keytool -exportcert        -storepass \$pass -keystore keystore -alias \$name -file key || return 2
  cp \${ca}/certs/\${name}.crt cert || return 2
  keytool -import  -noprompt -storepass \$pass -keystore keystore -alias $\name -trustcacerts -file cert || return 2
}

err() { echo "\$@" 1>&2; }
main \$@
EOF
}

err() { echo "$@" 1>&2; }

main $@
